// frontend/src/store/api/usersApi.js - VERSION FINALIS√âE

import { baseApi } from './baseApi'

export const usersApi = baseApi.injectEndpoints({
  endpoints: (builder) => ({
    
    // ============================================================================
    // R√âCUP√âRATION DES UTILISATEURS
    // ============================================================================
    
    // üìã R√âCUP√âRER TOUS LES UTILISATEURS (route backend impl√©ment√©e ‚úÖ)
    getAllUsers: builder.query({
      query: () => '/users',
      providesTags: ['User'],
      transformResponse: (response) => ({
        users: response.data || [],
        count: response.count || 0
      }),
    }),
    
    // üë§ R√âCUP√âRER LE PROFIL UTILISATEUR CONNECT√â (route existante ‚úÖ)
    getUserProfile: builder.query({
      query: () => '/users/profile',
      providesTags: ['UserProfile'],
      transformResponse: (response) => response.user,
    }),
    
    // üë§ R√âCUP√âRER UN UTILISATEUR SP√âCIFIQUE (route backend impl√©ment√©e ‚úÖ)
    getUserById: builder.query({
      query: (id) => `/users/${id}`,
      providesTags: (result, error, id) => [{ type: 'User', id }],
      transformResponse: (response) => response.data,
    }),

    // üìä STATISTIQUES DES UTILISATEURS (calcul√©es dynamiquement)
    getUserStats: builder.query({
      query: () => '/users',
      providesTags: ['User'],
      transformResponse: (response) => {
        const users = response.data || []
        
        // Calcul des statistiques √† partir des donn√©es r√©elles
        const stats = {
          total: users.length,
          superAdmins: users.filter(u => u.role === 'superAdmin').length,
          managers: users.filter(u => u.role === 'manager').length,
          formateurs: users.filter(u => u.role === 'user').length,
          active: users.filter(u => u.isActive === true).length,
          inactive: users.filter(u => u.isActive === false).length,
          temporaryPasswords: users.filter(u => u.isTemporaryPassword === true).length,
          cuisine: users.filter(u => u.role === 'user' && u.specialization === 'cuisine').length,
          service: users.filter(u => u.role === 'user' && u.specialization === 'service').length,
        }
        
        return stats
      },
    }),
    
    // ============================================================================
    // MUTATIONS - CR√âATION/MODIFICATION/SUPPRESSION
    // ============================================================================
    
    // ‚ûï CR√âER UN NOUVEL UTILISATEUR (route existante ‚úÖ)
    createUser: builder.mutation({
      query: (userData) => ({
        url: '/auth/create-user',
        method: 'POST',
        body: userData,
      }),
      invalidatesTags: ['User', 'UserProfile', 'Dashboard'],
      transformResponse: (response) => response.data,
      // Gestion d'erreur personnalis√©e
      transformErrorResponse: (response) => ({
        status: response.status,
        message: response.data?.message || 'Erreur lors de la cr√©ation de l\'utilisateur',
        errors: response.data?.errors || null
      }),
    }),
    
    // ‚úèÔ∏è METTRE √Ä JOUR UN UTILISATEUR (route backend impl√©ment√©e ‚úÖ)
    updateUser: builder.mutation({
      query: ({ id, ...userData }) => ({
        url: `/users/${id}`,
        method: 'PUT',
        body: userData,
      }),
      invalidatesTags: [(result, error, { id }) => [
        { type: 'User', id },
        'User',
        'UserProfile'
      ]],
      transformResponse: (response) => response.data,
      transformErrorResponse: (response) => ({
        status: response.status,
        message: response.data?.message || 'Erreur lors de la mise √† jour de l\'utilisateur',
        errors: response.data?.errors || null
      }),
    }),
    
    // üóëÔ∏è SUPPRIMER UN UTILISATEUR (route backend impl√©ment√©e ‚úÖ)
    deleteUser: builder.mutation({
      query: (id) => ({
        url: `/users/${id}`,
        method: 'DELETE',
      }),
      invalidatesTags: (result, error, id) => [
        { type: 'User', id },
        'User',
        'Dashboard'
      ],
      transformErrorResponse: (response) => ({
        status: response.status,
        message: response.data?.message || 'Erreur lors de la suppression de l\'utilisateur'
      }),
    }),
    
    // ============================================================================
    // GESTION DES MOTS DE PASSE
    // ============================================================================
    
    // üîÑ CHANGER LE MOT DE PASSE (route existante ‚úÖ)
    changeUserPassword: builder.mutation({
      query: ({ userId, newPassword }) => ({
        url: `/users/password/${userId}`,
        method: 'PATCH',
        body: { newPassword },
      }),
      invalidatesTags: (result, error, { userId }) => [
        { type: 'User', id: userId },
        'UserProfile'
      ],
      transformErrorResponse: (response) => ({
        status: response.status,
        message: response.data?.message || 'Erreur lors du changement de mot de passe'
      }),
    }),
    
    // üìß DEMANDER RESET MOT DE PASSE (route existante ‚úÖ)
    requestPasswordReset: builder.mutation({
      query: ({ email }) => ({
        url: '/users/request-password-reset',
        method: 'POST',
        body: { email },
      }),
      transformErrorResponse: (response) => ({
        status: response.status,
        message: response.data?.message || 'Erreur lors de la demande de r√©initialisation'
      }),
    }),
    
    // üîê R√âINITIALISER MOT DE PASSE (route existante ‚úÖ)
    resetPassword: builder.mutation({
      query: ({ token, password }) => ({
        url: '/users/reset-password',
        method: 'POST',
        body: { token, password },
      }),
      transformErrorResponse: (response) => ({
        status: response.status,
        message: response.data?.message || 'Erreur lors de la r√©initialisation du mot de passe'
      }),
    }),
    
    // üìß ENVOYER RAPPELS MOTS DE PASSE TEMPORAIRES (route existante ‚úÖ)
    sendPasswordReminder: builder.mutation({
      query: () => ({
        url: '/users/send-password-reminders',
        method: 'POST',
      }),
      // Invalide les stats pour actualiser le nombre de mots de passe temporaires
      invalidatesTags: ['User'],
      transformErrorResponse: (response) => ({
        status: response.status,
        message: response.data?.message || 'Erreur lors de l\'envoi des rappels'
      }),
    }),
    
    // ============================================================================
    // REQU√äTES SP√âCIALIS√âES
    // ============================================================================
    
    // üéØ R√âCUP√âRER TOUS LES FORMATEURS (utilise getAllUsers avec filtre c√¥t√© client)
   getAllTeachers: builder.query({
  query: () => '/users',
  providesTags: ['User'],
  transformResponse: (response) => {
    const allUsers = response.data || []
    const teachers = allUsers.filter(user => user.role === 'user' && user.isTeacher === true)

    return {
      teachers,
      count: teachers.length
    }
  },
}),
getTeachersOnly: builder.query({
  query: () => '/users/teachers',
  providesTags: ['User'],
  transformResponse: (response) => {
    const teachers = response.data || []
    return {
      teachers,
      count: teachers.length
    }
  }
}),

    
    // üîç RECHERCHER DES UTILISATEURS PAR CRIT√àRES
    searchUsers: builder.query({
      query: ({ role, specialization, isActive, search }) => {
        const params = new URLSearchParams()
        if (role) params.append('role', role)
        if (specialization) params.append('specialization', specialization)
        if (isActive !== undefined) params.append('isActive', isActive)
        if (search) params.append('search', search)
        
        return `/users?${params.toString()}`
      },
      providesTags: ['User'],
      transformResponse: (response) => ({
        users: response.data || [],
        count: response.count || 0
      }),
    }),
    
    // üìà OBTENIR LES UTILISATEURS AVEC MOTS DE PASSE TEMPORAIRES
    getUsersWithTempPasswords: builder.query({
      query: () => '/users',
      providesTags: ['User'],
      transformResponse: (response) => {
        const allUsers = response.data || []
        const usersWithTempPasswords = allUsers.filter(user => user.isTemporaryPassword === true)
        
        return {
          users: usersWithTempPasswords,
          count: usersWithTempPasswords.length
        }
      },
    }),
    
  }),
  overrideExisting: false,
})

// ============================================================================
// EXPORT DES HOOKS AVEC CONFIGURATION OPTIMIS√âE
// ============================================================================
export const {
  // Queries
  useGetAllUsersQuery,
  useGetTeachersOnlyQuery,
  useGetUserProfileQuery,
  useGetUserByIdQuery,
  useGetUserStatsQuery,
  useGetAllTeachersQuery,
  useSearchUsersQuery,
  useGetUsersWithTempPasswordsQuery,
  
  // Mutations
  useCreateUserMutation,
  useUpdateUserMutation,
  useDeleteUserMutation,
  useChangeUserPasswordMutation,
  useRequestPasswordResetMutation,
  useResetPasswordMutation,
  useSendPasswordReminderMutation,
  
  // Utilitaires pour le cache
  util: { 
    getRunningQueriesThunk,
    invalidateTags,
    resetApiState 
  }
} = usersApi

// ============================================================================
// HOOKS PERSONNALIS√âS POUR SIMPLIFIER L'USAGE
// ============================================================================

/**
 * Hook personnalis√© pour r√©cup√©rer les statistiques avec auto-refresh
 */
export const useUserStatsWithRefresh = (refreshInterval = 30000) => {
  return useGetUserStatsQuery(undefined, {
    pollingInterval: refreshInterval,
    refetchOnMountOrArgChange: true,
    refetchOnFocus: true,
  })
}

/**
 * Hook personnalis√© pour la liste des utilisateurs avec options avanc√©es
 */
export const useUsersListWithOptions = (options = {}) => {
  const {
    autoRefresh = false,
    refreshInterval = 60000,
    skipIfNoAuth = true
  } = options
  
  // ‚úÖ CORRECTION : Appel inconditionnel du hook
  const { data: userProfile } = useGetUserProfileQuery()
  
  return useGetAllUsersQuery(undefined, {
    pollingInterval: autoRefresh ? refreshInterval : 0,
    refetchOnMountOrArgChange: true,
    refetchOnFocus: true,
    skip: skipIfNoAuth && !userProfile,
  })
}

/**
 * Hook personnalis√© pour les formateurs avec filtres pr√©d√©finis
 */
export const useTeachersWithFilters = (filters = {}) => {
  const { specialization, isActive } = filters
  
  return useSearchUsersQuery({
    role: 'user',
    specialization,
    isActive
  }, {
    refetchOnMountOrArgChange: true,
  })
}